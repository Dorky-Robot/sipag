#!/usr/bin/env bash
# sipag — task queue feeder for Claude Code
#
# Reads a markdown checklist, feeds the next unchecked item to claude,
# marks it done, moves on.

set -euo pipefail

SIPAG_VERSION="2.0.0"

# Resolve project root
SIPAG_ROOT="$(cd "$(dirname "$0")/.." && pwd)"

# Source libraries
# shellcheck source=../lib/task.sh
source "${SIPAG_ROOT}/lib/task.sh"
# shellcheck source=../lib/run.sh
source "${SIPAG_ROOT}/lib/run.sh"
# shellcheck source=../lib/worker.sh
source "${SIPAG_ROOT}/lib/worker.sh"
# shellcheck source=../lib/setup.sh
source "${SIPAG_ROOT}/lib/setup.sh"
# shellcheck source=../lib/start.sh
source "${SIPAG_ROOT}/lib/start.sh"
# shellcheck source=../lib/merge.sh
source "${SIPAG_ROOT}/lib/merge.sh"
# shellcheck source=../lib/preflight.sh
source "${SIPAG_ROOT}/lib/preflight.sh"

# --- Defaults ---

SIPAG_FILE="${SIPAG_FILE:-./tasks.md}"
CONTINUE=0
DRY_RUN=0

# --- Help ---

usage() {
	cat <<'EOF'
sipag — autonomous dev agent powered by Claude Code

Usage:
  sipag start <owner/repo>       Prime session for agile workflow
  sipag work <owner/repo>        Pick up approved issues, code in Docker
  sipag merge <owner/repo>       Conversational PR merge session
  sipag next [-c] [-n] [-f]     Run next task from a markdown checklist
  sipag list [-f path]           Print all tasks with status
  sipag add "task" [-f path]     Append task to checklist
  sipag usage [--since Nd]       Show token usage and cost estimates
  sipag setup                    Configure sipag and Claude Code permissions
  sipag version                  Print version
  sipag help                     Show this help

Agile workflow:
  start → (converse, triage, refine, approve) → work → merge

Flags:
  -c, --continue     After completing, loop to the next task
  -n, --dry-run      Show what would run, don't invoke claude
  -f, --file <path>  Task file (default: ./tasks.md or $SIPAG_FILE)

Config (~/.sipag/config):
  batch_size=4                 Max parallel Docker containers
  image=ghcr.io/dorky-robot/sipag-worker:latest    Docker image for workers
  timeout=1800                 Per-task timeout in seconds
  poll_interval=120            Seconds between polling for new issues

Environment:
  SIPAG_FILE              Task file path (default: ./tasks.md)
  SIPAG_TIMEOUT           Claude timeout in seconds (default: 600)
  SIPAG_MODEL             Model override
  SIPAG_PROMPT_PREFIX     Prepended to every prompt
  SIPAG_SKIP_PERMISSIONS  Set 0 for interactive mode (default: 1)
  SIPAG_CLAUDE_ARGS       Extra raw args to claude
EOF
}

# --- Commands ---

cmd_next() {
	while true; do
		if ! task_parse_next "$SIPAG_FILE"; then
			echo "No pending tasks in ${SIPAG_FILE}"
			return 0
		fi

		echo "==> Task ${TASK_LINE}: ${TASK_TITLE}"

		if [[ $DRY_RUN -eq 1 ]]; then
			if [[ -n "$TASK_BODY" ]]; then
				echo ""
				echo "$TASK_BODY"
			fi
			echo ""
			echo "(dry run — skipping claude)"
			return 0
		fi

		if run_claude "$TASK_TITLE" "$TASK_BODY"; then
			task_mark_done "$SIPAG_FILE" "$TASK_LINE"
			echo "==> Done: ${TASK_TITLE}"
		else
			local rc=$?
			echo "==> Failed (exit ${rc}): ${TASK_TITLE}"
			return $rc
		fi

		if [[ $CONTINUE -eq 0 ]]; then
			return 0
		fi

		echo ""
	done
}

cmd_list() {
	task_list "$SIPAG_FILE"
}

cmd_add() {
	if [[ $# -eq 0 ]]; then
		echo "Usage: sipag add \"task text\" [-f path]"
		return 1
	fi

	local text="$1"
	task_add "$SIPAG_FILE" "$text"
	echo "Added: ${text}"
}

cmd_start() {
	local repo="${1:?Usage: sipag start <owner/repo>}"
	preflight_gh_auth || return 1
	preflight_repo "$repo" || return 1
	start_run "$repo"
}

cmd_setup() {
	setup_run
}

cmd_work() {
	local repo="${1:?Usage: sipag work <owner/repo>}"
	worker_load_config
	preflight_auth || return 1
	preflight_docker_running || return 1
	preflight_docker_image "${WORKER_IMAGE}" || return 1
	preflight_gh_auth || return 1
	worker_init
	worker_loop "$repo"
}

cmd_merge() {
	local repo="${1:?Usage: sipag merge <owner/repo>}"
	merge_run "$repo"
}

cmd_version() {
	echo "sipag ${SIPAG_VERSION}"
}

cmd_usage() {
	local since="" log_file
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--since)
			shift
			since="${1:?--since requires a value (e.g. 7d, 24h, 1w)}"
			shift
			;;
		*)
			shift
			;;
		esac
	done

	log_file="${SIPAG_DIR}/usage.log"
	if [[ ! -f "$log_file" ]]; then
		echo "No usage data yet. Usage is recorded automatically when workers complete."
		echo "Usage log: ${log_file}"
		return 0
	fi

	local period_label="All time"
	[[ -n "$since" ]] && period_label="Last ${since}"
	echo "${period_label}:"

	if command -v jq &>/dev/null; then
		# Compute cutoff timestamp for --since filter (empty = no filter)
		local cutoff=""
		if [[ -n "$since" ]]; then
			local n
			if [[ "$since" =~ ^([0-9]+)d$ ]]; then
				n="${BASH_REMATCH[1]}"
				cutoff=$(date -u -d "-${n} days" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null \
					|| date -u -v"-${n}d" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || true)
			elif [[ "$since" =~ ^([0-9]+)h$ ]]; then
				n="${BASH_REMATCH[1]}"
				cutoff=$(date -u -d "-${n} hours" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null \
					|| date -u -v"-${n}H" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || true)
			elif [[ "$since" =~ ^([0-9]+)w$ ]]; then
				n=$(( ${BASH_REMATCH[1]} * 7 ))
				cutoff=$(date -u -d "-${n} days" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null \
					|| date -u -v"-${n}d" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || true)
			fi
		fi

		# Pass cutoff as a jq variable to avoid shell quoting issues.
		# Per-repo breakdown followed by grand total.
		jq -rs --arg cutoff "$cutoff" '
			[
				.[] |
				if $cutoff == "" then . else select(.ts >= $cutoff) end
			] |
			(
				group_by(.repo)[] |
				(.[0].repo)                              as $repo |
				([.[].input_tokens  // 0] | add)         as $inp  |
				([.[].output_tokens // 0] | add)         as $out  |
				([.[].cost_usd      // 0] | add)         as $cost |
				(length)                                 as $runs |
				"  \($repo):  \($inp) input / \($out) output  ~$\($cost | . * 100 | round / 100)  (\($runs) run\(if $runs == 1 then "" else "s" end))"
			),
			(
				([.[].input_tokens  // 0] | add)         as $inp  |
				([.[].output_tokens // 0] | add)         as $out  |
				([.[].cost_usd      // 0] | add)         as $cost |
				(length)                                 as $runs |
				"  Total:  \($inp) input / \($out) output  ~$\($cost | . * 100 | round / 100)  (\($runs) run\(if $runs == 1 then "" else "s" end))"
			)
		' "$log_file" 2>/dev/null || true
	else
		local runs
		runs=$(wc -l < "$log_file")
		echo "  ${runs} run(s) recorded (install jq for token counts and cost totals)."
	fi

	echo ""
	echo "  Log: ${log_file}"
}

# --- Argument parsing ---

main() {
	local command=""
	local add_text=""

	local work_repo=""
	local start_repo=""
	local merge_repo=""
	local usage_args=()

	while [[ $# -gt 0 ]]; do
		case "$1" in
		start)
			command="start"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				start_repo="$1"
				shift
			fi
			;;
		setup)
			command="setup"
			shift
			;;
		work)
			command="work"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				work_repo="$1"
				shift
			fi
			;;
		merge)
			command="merge"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				merge_repo="$1"
				shift
			fi
			;;
		usage)
			command="usage"
			shift
			# Collect remaining args for cmd_usage
			while [[ $# -gt 0 ]]; do
				usage_args+=("$1")
				shift
			done
			;;
		next)
			command="next"
			shift
			;;
		list)
			command="list"
			shift
			;;
		add)
			command="add"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				add_text="$1"
				shift
			fi
			;;
		version | --version)
			cmd_version
			return 0
			;;
		help | --help | -h)
			usage
			return 0
			;;
		-c | --continue)
			CONTINUE=1
			shift
			;;
		-n | --dry-run)
			DRY_RUN=1
			shift
			;;
		-f | --file)
			shift
			SIPAG_FILE="${1:?--file requires a path}"
			shift
			;;
		-*)
			echo "Unknown flag: $1"
			usage
			return 1
			;;
		*)
			# If no command yet, treat as command
			if [[ -z "$command" ]]; then
				echo "Unknown command: $1"
				usage
				return 1
			fi
			shift
			;;
		esac
	done

	# Default command
	if [[ -z "$command" ]]; then
		command="next"
	fi

	case "$command" in
	start) cmd_start "$start_repo" ;;
	setup) cmd_setup ;;
	work) cmd_work "$work_repo" ;;
	merge) cmd_merge "$merge_repo" ;;
	usage) cmd_usage "${usage_args[@]}" ;;
	next) cmd_next ;;
	list) cmd_list ;;
	add) cmd_add "$add_text" ;;
	esac
}

main "$@"
