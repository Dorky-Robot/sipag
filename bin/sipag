#!/usr/bin/env bash
# sipag — sandbox launcher for Claude Code
#
# Claude Code is the orchestrator. sipag spins up isolated Docker sandboxes
# and makes progress visible.

set -euo pipefail

SIPAG_VERSION="2.0.0"

# Resolve project root
SIPAG_ROOT="$(cd "$(dirname "$0")/.." && pwd)"

# Source libraries
# shellcheck source=../lib/task.sh
source "${SIPAG_ROOT}/lib/task.sh"
# shellcheck source=../lib/run.sh
source "${SIPAG_ROOT}/lib/run.sh"
# shellcheck source=../lib/repo.sh
source "${SIPAG_ROOT}/lib/repo.sh"
# shellcheck source=../lib/notify.sh
source "${SIPAG_ROOT}/lib/notify.sh"
# shellcheck source=../lib/executor.sh
source "${SIPAG_ROOT}/lib/executor.sh"

# --- Defaults ---

SIPAG_DIR="${SIPAG_DIR:-${HOME}/.sipag}"
SIPAG_FILE="${SIPAG_FILE:-./tasks.md}"
CONTINUE=0
DRY_RUN=0
ADD_REPO=""
ADD_PRIORITY="medium"

# --- Help ---

usage() {
	cat <<'EOF'
sipag — sandbox launcher for Claude Code

Usage:
  sipag run --repo <url> [--issue <n>] [-b] "<task>"
                                Launch a Docker sandbox for a task
  sipag ps                      List running and recent tasks
  sipag logs <id>               Print log for a task
  sipag kill <id>               Kill a running task container
  sipag start                   Process queue/ serially (uses sipag run internally)
  sipag init                    Create ~/.sipag/{queue,running,done,failed}
  sipag add "task" [--repo <name>] [--priority <level>]
                                Queue a task (writes YAML frontmatter to queue/)
  sipag list [-f path]          Print all tasks with status
  sipag next [-c] [-n] [-f]     Find first - [ ], run claude, mark - [x]
  sipag show <name>             Print task file and log (searches all dirs)
  sipag retry <name>            Move task from failed/ back to queue/
  sipag repo add <name> <url>   Register a repo
  sipag repo list               List registered repos
  sipag status                  Show queue state across all directories
  sipag version                 Print version
  sipag help                    Show this help

Run flags:
  --repo <url>              Repository URL to clone (required)
  --issue <n>               GitHub issue number to associate
  -b, --background          Run in background (default: foreground)

Queue flags:
  -c, --continue            After completing, loop to the next task
  -n, --dry-run             Show what would run, don't invoke claude
  -f, --file <path>         Task file (default: ./tasks.md or $SIPAG_FILE)
      --repo <name>         Repository name for the queued task
      --priority <level>    Priority level (default: medium)

Environment:
  SIPAG_DIR               Base directory (default: ~/.sipag)
  SIPAG_FILE              Task file path (default: ./tasks.md)
  SIPAG_IMAGE             Docker base image (default: sipag-worker:latest)
  SIPAG_TIMEOUT           Container timeout in seconds (default: 1800)
  SIPAG_MODEL             Model override
  SIPAG_PROMPT_PREFIX     Prepended to every prompt
  SIPAG_SKIP_PERMISSIONS  Set 0 for interactive mode (default: 1)
  SIPAG_CLAUDE_ARGS       Extra raw args to claude
  SIPAG_NOTIFY            Set 0 to disable desktop notifications (default: 1)
EOF
}

# --- Commands ---

cmd_init() {
	sipag_init_dirs "${SIPAG_DIR}"
}

cmd_start() {
	sipag_init_dirs "${SIPAG_DIR}" >/dev/null
	echo "sipag executor starting (queue: ${SIPAG_DIR}/queue)"
	executor_run
}

cmd_next() {
	while true; do
		if ! task_parse_next "$SIPAG_FILE"; then
			echo "No pending tasks in ${SIPAG_FILE}"
			return 0
		fi

		echo "==> Task ${TASK_LINE}: ${TASK_TITLE}"

		if [[ $DRY_RUN -eq 1 ]]; then
			if [[ -n "$TASK_BODY" ]]; then
				echo ""
				echo "$TASK_BODY"
			fi
			echo ""
			echo "(dry run — skipping claude)"
			return 0
		fi

		if run_claude "$TASK_TITLE" "$TASK_BODY"; then
			task_mark_done "$SIPAG_FILE" "$TASK_LINE"
			echo "==> Done: ${TASK_TITLE}"
		else
			local rc=$?
			echo "==> Failed (exit ${rc}): ${TASK_TITLE}"
			return $rc
		fi

		if [[ $CONTINUE -eq 0 ]]; then
			return 0
		fi

		echo ""
	done
}

cmd_list() {
	task_list "$SIPAG_FILE"
}

cmd_add() {
	local text="$1"

	if [[ -z "$text" ]]; then
		echo "Usage: sipag add \"task text\" [--repo <name>] [--priority <level>]"
		return 1
	fi

	# Auto-init directory structure if it doesn't exist yet
	if [[ ! -d "${SIPAG_DIR}/queue" ]]; then
		sipag_init_dirs "${SIPAG_DIR}" >/dev/null
	fi

	if [[ -n "$ADD_REPO" ]]; then
		# Frontmatter format: write a named file to queue/
		local filename
		filename=$(task_next_filename "${SIPAG_DIR}/queue" "$text")
		task_write_file "${SIPAG_DIR}/queue/${filename}" "$text" "$ADD_REPO" "$ADD_PRIORITY"
		echo "Added: ${text}"
	else
		# Legacy format: append checklist item to SIPAG_FILE
		task_add "$SIPAG_FILE" "$text"
		echo "Added: ${text}"
	fi
}

cmd_repo() {
	local subcmd="${1:-}"
	local name="${2:-}"
	local url="${3:-}"
	local conf="${SIPAG_DIR}/repos.conf"

	case "$subcmd" in
	add)
		if [[ -z "$name" ]]; then
			echo "Usage: sipag repo add <name> <url>" >&2
			return 1
		fi
		if [[ -z "$url" ]]; then
			echo "Usage: sipag repo add <name> <url>" >&2
			return 1
		fi
		if [[ -f "$conf" ]] && grep -q "^${name}=" "$conf"; then
			echo "Error: repo '${name}' already exists" >&2
			return 1
		fi
		echo "${name}=${url}" >>"$conf"
		echo "Registered: ${name}=${url}"
		;;
	list)
		if [[ ! -f "$conf" ]]; then
			echo "No repos registered. Use: sipag repo add <name> <url>"
			return 0
		fi
		cat "$conf"
		;;
	*)
		echo "Usage: sipag repo add <name> <url>" >&2
		echo "       sipag repo list" >&2
		return 1
		;;
	esac
}

cmd_status() {
	local -a labels=("Queue" "Running" "Done" "Failed")
	local -a subdirs=("queue" "running" "done" "failed")
	local i

	for ((i = 0; i < ${#labels[@]}; i++)); do
		local label="${labels[$i]}"
		local dir="${SIPAG_DIR}/${subdirs[$i]}"
		local -a items=()

		if [[ -d "$dir" ]]; then
			local f
			for f in "${dir}/"*; do
				[[ -e "$f" ]] && items+=("$(basename "$f")")
			done
		fi

		local count="${#items[@]}"
		if [[ $count -gt 0 ]]; then
			echo "${label} (${count}):"
			printf '%s\n' "${items[@]}" | sort | while IFS= read -r item; do
				echo "  ${item}"
			done
		fi
	done
}

cmd_version() {
	echo "sipag ${SIPAG_VERSION}"
}

cmd_show() {
	if [[ $# -eq 0 ]]; then
		echo "Usage: sipag show <name>"
		return 1
	fi
	local name="$1"
	local found_file=""
	local found_status=""
	for dir_status in queue running done failed; do
		local candidate="${SIPAG_DIR}/${dir_status}/${name}.md"
		if [[ -f "$candidate" ]]; then
			found_file="$candidate"
			found_status="$dir_status"
			break
		fi
	done
	if [[ -z "$found_file" ]]; then
		echo "Error: task '${name}' not found"
		return 1
	fi
	echo "=== Task: ${name} ==="
	echo "Status: ${found_status}"
	cat "$found_file"
	local log_file="${SIPAG_DIR}/${found_status}/${name}.log"
	if [[ -f "$log_file" ]]; then
		echo "=== Log ==="
		cat "$log_file"
	fi
}

cmd_retry() {
	if [[ $# -eq 0 ]]; then
		echo "Usage: sipag retry <name>"
		return 1
	fi
	local name="$1"
	local failed_file="${SIPAG_DIR}/failed/${name}.md"
	local log_file="${SIPAG_DIR}/failed/${name}.log"
	if [[ ! -f "$failed_file" ]]; then
		echo "Error: task '${name}' not found in failed/"
		return 1
	fi
	mv "$failed_file" "${SIPAG_DIR}/queue/${name}.md"
	if [[ -f "$log_file" ]]; then
		rm "$log_file"
	fi
	echo "Retrying: ${name} (moved to queue)"
}

# sipag run — launch a Docker sandbox for a task
cmd_run() {
	local repo_url=""
	local issue=""
	local background=0
	local description=""

	while [[ $# -gt 0 ]]; do
		case "$1" in
		--repo)
			shift
			repo_url="${1:?--repo requires a URL}"
			shift
			;;
		--issue)
			shift
			issue="${1:?--issue requires a number}"
			shift
			;;
		-b | --background)
			background=1
			shift
			;;
		-*)
			echo "Unknown flag: $1" >&2
			echo "Usage: sipag run --repo <url> [--issue <n>] [-b] \"<task>\"" >&2
			return 1
			;;
		*)
			description="$1"
			shift
			;;
		esac
	done

	if [[ -z "$repo_url" ]]; then
		echo "Usage: sipag run --repo <url> [--issue <n>] [-b] \"<task>\"" >&2
		echo "  --repo is required" >&2
		return 1
	fi

	if [[ -z "$description" ]]; then
		echo "Usage: sipag run --repo <url> [--issue <n>] [-b] \"<task>\"" >&2
		echo "  task description is required" >&2
		return 1
	fi

	# Auto-init if needed
	if [[ ! -d "${SIPAG_DIR}/running" ]]; then
		sipag_init_dirs "${SIPAG_DIR}" >/dev/null
	fi

	# Generate unique task ID from timestamp + slugified description
	local slug
	slug=$(task_slugify "$description")
	local task_id
	task_id="$(date +%Y%m%d%H%M%S)-${slug:0:30}"
	# Strip trailing hyphens from the slug portion
	task_id="${task_id%-}"

	echo "Task ID: ${task_id}"

	executor_run_impl "${task_id}" "${repo_url}" "${description}" "${issue}" "${background}"
}

# sipag ps — list running and recent tasks
cmd_ps() {
	local now
	now=$(date +%s)

	printf '%-44s  %-8s  %-10s  %s\n' "ID" "STATUS" "DURATION" "REPO"

	local found=0
	for dir_status in running done failed; do
		local dir="${SIPAG_DIR}/${dir_status}"
		[[ -d "$dir" ]] || continue

		local f
		for f in "${dir}"/*.md; do
			[[ -f "$f" ]] || continue

			local task_id
			task_id="$(basename "$f" .md)"

			# Parse metadata from tracking file
			local repo started ended
			repo=$(grep -m1 "^repo:" "$f" 2>/dev/null | cut -d' ' -f2- || true)
			started=$(grep -m1 "^started:" "$f" 2>/dev/null | cut -d' ' -f2- || true)
			ended=$(grep -m1 "^ended:" "$f" 2>/dev/null | cut -d' ' -f2- || true)

			# Compute duration
			local duration="-"
			if [[ -n "$started" ]]; then
				local started_epoch ended_epoch
				if [[ "$(uname)" == "Darwin" ]]; then
					started_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$started" +%s 2>/dev/null || echo "$now")
				else
					started_epoch=$(date -d "$started" +%s 2>/dev/null || echo "$now")
				fi
				if [[ -n "$ended" ]]; then
					if [[ "$(uname)" == "Darwin" ]]; then
						ended_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$ended" +%s 2>/dev/null || echo "$now")
					else
						ended_epoch=$(date -d "$ended" +%s 2>/dev/null || echo "$now")
					fi
				else
					ended_epoch="$now"
				fi
				local diff=$((ended_epoch - started_epoch))
				if [[ $diff -lt 60 ]]; then
					duration="${diff}s"
				elif [[ $diff -lt 3600 ]]; then
					duration="$((diff / 60))m$((diff % 60))s"
				else
					duration="$((diff / 3600))h$((diff % 3600 / 60))m"
				fi
			fi

			printf '%-44s  %-8s  %-10s  %s\n' \
				"${task_id:0:44}" "${dir_status}" "${duration}" "${repo:-unknown}"
			found=1
		done
	done

	if [[ "$found" -eq 0 ]]; then
		echo "No tasks found."
	fi
}

# sipag logs <id> — print log for a task
cmd_logs() {
	local task_id="${1:-}"
	if [[ -z "$task_id" ]]; then
		echo "Usage: sipag logs <id>" >&2
		return 1
	fi

	for dir_status in running done failed; do
		local log_file="${SIPAG_DIR}/${dir_status}/${task_id}.log"
		if [[ -f "$log_file" ]]; then
			cat "$log_file"
			return 0
		fi
	done

	echo "Error: no log found for task '${task_id}'" >&2
	return 1
}

# sipag kill <id> — kill a running container and move task to failed/
cmd_kill() {
	local task_id="${1:-}"
	if [[ -z "$task_id" ]]; then
		echo "Usage: sipag kill <id>" >&2
		return 1
	fi

	local tracking_file="${SIPAG_DIR}/running/${task_id}.md"
	if [[ ! -f "$tracking_file" ]]; then
		echo "Error: task '${task_id}' not found in running/" >&2
		return 1
	fi

	# Container name is deterministic: sipag-<task_id>
	local container_name="sipag-${task_id}"

	# Kill the Docker container (ignore errors if already stopped)
	docker kill "${container_name}" 2>/dev/null || true

	# Move task and log to failed/
	local log_file="${SIPAG_DIR}/running/${task_id}.log"
	mv "${tracking_file}" "${SIPAG_DIR}/failed/${task_id}.md"
	[[ -f "$log_file" ]] && mv "$log_file" "${SIPAG_DIR}/failed/${task_id}.log"

	echo "Killed: ${task_id}"
}

# --- Argument parsing ---

main() {
	local command=""
	local add_text=""
	local cmd_name_arg=""
	local repo_subcmd=""
	local repo_name=""
	local repo_url_arg=""
	local -a run_args=()

	while [[ $# -gt 0 ]]; do
		case "$1" in
		init)
			command="init"
			shift
			;;
		next)
			command="next"
			shift
			;;
		list)
			command="list"
			shift
			;;
		add)
			command="add"
			shift
			;;
		show)
			command="show"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				cmd_name_arg="$1"
				shift
			fi
			;;
		retry)
			command="retry"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				cmd_name_arg="$1"
				shift
			fi
			;;
		start)
			command="start"
			shift
			;;
		run)
			command="run"
			shift
			run_args=("$@")
			break
			;;
		ps)
			command="ps"
			shift
			;;
		logs)
			command="logs"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				cmd_name_arg="$1"
				shift
			fi
			;;
		kill)
			command="kill"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				cmd_name_arg="$1"
				shift
			fi
			;;
		repo)
			command="repo"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				repo_subcmd="$1"
				shift
			fi
			if [[ $# -gt 0 && "$1" != -* ]]; then
				repo_name="$1"
				shift
			fi
			if [[ $# -gt 0 && "$1" != -* ]]; then
				repo_url_arg="$1"
				shift
			fi
			;;
		status)
			command="status"
			shift
			;;
		version | --version)
			cmd_version
			return 0
			;;
		help | --help | -h)
			usage
			return 0
			;;
		-c | --continue)
			CONTINUE=1
			shift
			;;
		-n | --dry-run)
			DRY_RUN=1
			shift
			;;
		-f | --file)
			shift
			SIPAG_FILE="${1:?--file requires a path}"
			shift
			;;
		--repo)
			shift
			ADD_REPO="${1:?--repo requires a name}"
			shift
			;;
		--priority)
			shift
			ADD_PRIORITY="${1:?--priority requires a level}"
			shift
			;;
		-*)
			echo "Unknown flag: $1"
			usage
			return 1
			;;
		*)
			# If no command yet, treat as unknown command
			if [[ -z "$command" ]]; then
				echo "Unknown command: $1"
				usage
				return 1
			fi
			# Capture positional argument for add subcommand
			if [[ "$command" == "add" && -z "$add_text" ]]; then
				add_text="$1"
			fi
			shift
			;;
		esac
	done

	# Default command
	if [[ -z "$command" ]]; then
		command="next"
	fi

	case "$command" in
	init) cmd_init ;;
	next) cmd_next ;;
	list) cmd_list ;;
	add) cmd_add "$add_text" ;;
	show) cmd_show "$cmd_name_arg" ;;
	retry) cmd_retry "$cmd_name_arg" ;;
	start) cmd_start ;;
	run) cmd_run "${run_args[@]+"${run_args[@]}"}" ;;
	ps) cmd_ps ;;
	logs) cmd_logs "$cmd_name_arg" ;;
	kill) cmd_kill "$cmd_name_arg" ;;
	repo) cmd_repo "$repo_subcmd" "$repo_name" "$repo_url_arg" ;;
	status) cmd_status ;;
	esac
}

main "$@"
