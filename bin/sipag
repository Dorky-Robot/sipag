#!/usr/bin/env bash
# sipag — autonomous dev agent powered by Claude Code

set -euo pipefail

SIPAG_VERSION="2.0.0"

# Resolve project root — follows symlinks so Homebrew installs work correctly.
# Works from both dev checkout (script in bin/) and any installed location
# (e.g. Homebrew symlinks /usr/local/bin/sipag → prefix/bin/sipag).
_sipag_script="${BASH_SOURCE[0]}"
while [[ -L "$_sipag_script" ]]; do
	_sipag_dir="$(cd "$(dirname "$_sipag_script")" && pwd)"
	_sipag_script="$(readlink "$_sipag_script")"
	[[ "$_sipag_script" = /* ]] || _sipag_script="${_sipag_dir}/${_sipag_script}"
done
SIPAG_ROOT="$(cd "$(dirname "$_sipag_script")/.." && pwd)"
unset _sipag_script _sipag_dir

# Source libraries
# shellcheck source=../lib/worker.sh
source "${SIPAG_ROOT}/lib/worker.sh"
# shellcheck source=../lib/setup.sh
source "${SIPAG_ROOT}/lib/setup.sh"
# shellcheck source=../lib/start.sh
source "${SIPAG_ROOT}/lib/start.sh"
# shellcheck source=../lib/merge.sh
source "${SIPAG_ROOT}/lib/merge.sh"
# shellcheck source=../lib/preflight.sh
source "${SIPAG_ROOT}/lib/preflight.sh"
# shellcheck source=../lib/doctor.sh
source "${SIPAG_ROOT}/lib/doctor.sh"
# refresh-docs is sourced transitively via lib/worker.sh → lib/refresh-docs.sh

# --- Defaults ---

export WORKER_ONCE=0

# --- Help ---

usage() {
	cat <<'EOF'
sipag — autonomous dev agent powered by Claude Code

Usage:
  sipag start [<owner/repo>]           Prime session for agile workflow (all repos if omitted)
  sipag work [<owner/repo>] [--once]   Pick up approved issues, code in Docker (all repos if omitted)
  sipag refresh-docs <owner/repo>      Generate/update ARCHITECTURE.md and VISION.md via Claude
  sipag status                         Show worker state across all repos
  sipag drain                          Signal workers to finish current batch and exit
  sipag resume                         Clear drain signal so workers continue polling
  sipag merge <owner/repo>             Conversational PR merge session
  sipag setup                          Configure sipag and Claude Code permissions
  sipag doctor                         Diagnose setup problems and print fix commands
  sipag version                        Print version
  sipag help                           Show this help

  sipag run <task>                     Launch a Docker sandbox for a task
  sipag ps                             List running and recent tasks
  sipag logs <id>                      Print the log for a task
  sipag kill <id>                      Kill a running container
  sipag repo add|list                  Manage registered repos
  sipag tui                            Launch interactive TUI

Agile workflow:
  start → (converse, triage, refine, approve) → work → merge

Flags:
      --once         (work) Process one polling cycle and exit (useful for testing)
      --check        (refresh-docs) Only refresh if ARCHITECTURE.md is stale

Config (~/.sipag/config):
  batch_size=1                 Max parallel Docker containers (default: 1, max: 5)
  image=ghcr.io/dorky-robot/sipag-worker:latest    Docker image for workers
  timeout=1800                 Per-task timeout in seconds
  poll_interval=120            Seconds between polling for new issues
  doc_refresh_interval=10      Polling cycles between auto doc refreshes (0 = disabled)

Environment:
  SIPAG_TIMEOUT                Claude timeout in seconds (default: 600)
  SIPAG_BATCH_SIZE             Max parallel Docker containers (default: 1, max: 5)
  SIPAG_DOC_REFRESH_INTERVAL   Cycles between auto doc refreshes (default: 10, 0 = disabled)
  SIPAG_MODEL                  Model override
  SIPAG_PROMPT_PREFIX          Prepended to every prompt
  SIPAG_SKIP_PERMISSIONS       Set 0 for interactive mode (default: 1)
  SIPAG_CLAUDE_ARGS            Extra raw args to claude
EOF
}

# --- Commands ---

cmd_start() {
	preflight_gh_auth || return 1
	local repo="${1:-}"
	if [[ -n "$repo" ]]; then
		preflight_repo "$repo" || return 1
		start_run "$repo"
	else
		start_run_all
	fi
}

cmd_setup() {
	setup_run
}

cmd_work() {
	worker_load_config
	preflight_auth || return 1
	preflight_docker_running || return 1
	# Auto-pull image if not present
	if ! docker image inspect "${WORKER_IMAGE}" &>/dev/null; then
		echo "Worker image '${WORKER_IMAGE}' not found — pulling..."
		docker pull "${WORKER_IMAGE}" || {
			echo "Error: Could not pull '${WORKER_IMAGE}'. Run 'sipag setup' to configure."
			return 1
		}
	fi
	preflight_gh_auth || return 1
	if [[ -f "${SIPAG_DIR}/drain" ]]; then
		echo "Warning: stale drain signal found. Clearing it and starting normally."
		echo "Use 'sipag drain' to signal a graceful shutdown."
		rm -f "${SIPAG_DIR}/drain"
	fi

	local -a repos=()
	if [[ -n "${1:-}" ]]; then
		repos=("$1")
	else
		# Try repos.conf
		local conf="${SIPAG_DIR}/repos.conf"
		if [[ -f "$conf" ]]; then
			local name url
			while IFS='=' read -r name url; do
				name="${name// /}"
				url="${url// /}"
				[[ -z "$name" || "$name" == \#* ]] && continue
				url="${url%.git}"
				url="${url#https://github.com/}"
				repos+=("$url")
			done < "$conf"
		fi
		# Fall back to current git repo
		if [[ ${#repos[@]} -eq 0 ]]; then
			local detected
			detected=$(git remote get-url origin 2>/dev/null || true)
			detected="${detected%.git}"
			detected="${detected#https://github.com/}"
			detected="${detected#git@github.com:}"
			if [[ -n "$detected" ]]; then
				repos+=("$detected")
			else
				echo "Error: Not in a git repo and no repos registered."
				echo "  Run from a git repo, or: sipag repo add <name> <url>"
				return 1
			fi
		fi
	fi

	# Delegate to the Rust worker loop
	local -a sipag_args=()
	[[ "$WORKER_ONCE" == "1" ]] && sipag_args+=(--once)
	sipag_args+=("${repos[@]}")

	if command -v sipag-cli &>/dev/null; then
		exec sipag-cli work "${sipag_args[@]}"
	else
		echo "Error: sipag-cli not found. Run 'make install' or 'cargo install --path sipag'"
		return 1
	fi
}

cmd_drain() {
	mkdir -p "$SIPAG_DIR"
	touch "${SIPAG_DIR}/drain"
	echo "Drain signal sent. Running workers will finish their current batch and exit."
	echo "Use 'sipag resume' to cancel."
}

cmd_resume() {
	rm -f "${SIPAG_DIR}/drain"
	echo "Drain signal cleared. Workers will continue polling."
}

cmd_status() {
	# Auto-setup on first run (directories not initialized)
	if [[ ! -d "${SIPAG_DIR}/queue" ]]; then
		echo "First run detected — running setup..."
		setup_run || true
	fi

	# Always launch TUI in an interactive terminal
	if [[ -t 1 ]] && command -v sipag-tui &>/dev/null; then
		exec sipag-tui
	fi

	# Plain text table (piped output or TUI not installed)
	local workers_dir="${SIPAG_DIR}/workers"
	printf "%-24s %-7s %-9s %-10s %s\n" "REPO" "ISSUE" "STATUS" "DURATION" "BRANCH"

	local running=0 done_count=0 failed=0
	if [[ -d "$workers_dir" ]]; then
		for f in "$workers_dir"/*.json; do
			[[ -f "$f" ]] || continue
			local repo issue_num status duration_s branch pr_num display_branch duration
			repo=$(jq -r '.repo // ""' "$f")
			issue_num=$(jq -r '.issue_num // ""' "$f")
			status=$(jq -r '.status // ""' "$f")
			duration_s=$(jq -r 'if .duration_s != null then (.duration_s | tostring) else "" end' "$f")
			branch=$(jq -r '.branch // ""' "$f")
			pr_num=$(jq -r 'if .pr_num != null then (.pr_num | tostring) else "" end' "$f")

			# Format duration
			duration="-"
			if [[ -n "$duration_s" && "$duration_s" =~ ^[0-9]+$ ]]; then
				duration="$(( duration_s / 60 ))m$(( duration_s % 60 ))s"
			fi

			# Format branch/PR column
			if [[ "$status" == "done" && -n "$pr_num" ]]; then
				display_branch="PR #${pr_num}"
			else
				display_branch="$branch"
			fi

			case "$status" in
				running) running=$(( running + 1 )) ;;
				done)    done_count=$(( done_count + 1 )) ;;
				failed)  failed=$(( failed + 1 )) ;;
			esac

			printf "%-24s %-7s %-9s %-10s %s\n" \
				"$repo" "#${issue_num}" "$status" "$duration" "$display_branch"
		done
	fi

	echo ""
	echo "${running} running · ${done_count} done · ${failed} failed"
}

cmd_merge() {
	local repo="${1:-}"
	if [[ -z "$repo" ]]; then
		repo=$(git remote get-url origin 2>/dev/null || true)
		repo="${repo%.git}"
		repo="${repo#https://github.com/}"
		repo="${repo#git@github.com:}"
	fi
	if [[ -z "$repo" ]]; then
		echo "Error: Not in a git repo. Usage: sipag merge <owner/repo>"
		return 1
	fi
	merge_run "$repo"
}

cmd_doctor() {
	doctor_run
}

# Generate or update ARCHITECTURE.md (and handle VISION.md) via a Claude worker.
# Accepts an optional --check flag: only refresh if ARCHITECTURE.md is stale.
cmd_refresh_docs() {
	local repo="${1:-}"
	local check_mode="${2:-}"

	if [[ -z "$repo" ]]; then
		echo "Usage: sipag refresh-docs <owner/repo> [--check]"
		return 1
	fi

	preflight_repo "$repo" || return 1
	preflight_gh_auth || return 1
	preflight_auth || return 1
	preflight_docker_running || return 1

	worker_load_config
	worker_init "$repo"

	refresh_docs_run "$repo" "$check_mode"
}

cmd_version() {
	echo "sipag ${SIPAG_VERSION}"
}

# --- Argument parsing ---

main() {
	local command=""

	local work_repo=""
	local start_repo=""
	local merge_repo=""
	local refresh_docs_repo=""
	local refresh_docs_check=""

	while [[ $# -gt 0 ]]; do
		case "$1" in
		start)
			command="start"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				start_repo="$1"
				shift
			fi
			;;
		setup)
			command="setup"
			shift
			;;
		work)
			command="work"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				work_repo="$1"
				shift
			fi
			;;
		refresh-docs)
			command="refresh_docs"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				refresh_docs_repo="$1"
				shift
			fi
			;;
		drain)
			command="drain"
			shift
			;;
		resume)
			command="resume"
			shift
			;;
		status)
			command="status"
			shift
			;;
		merge)
			command="merge"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				merge_repo="$1"
				shift
			fi
			;;
		doctor)
			command="doctor"
			shift
			;;
		version | --version)
			cmd_version
			return 0
			;;
		help | --help | -h)
			usage
			return 0
			;;
		--once)
			export WORKER_ONCE=1
			shift
			;;
		--check)
			refresh_docs_check="--check"
			shift
			;;
		-*)
			echo "Unknown flag: $1"
			usage
			return 1
			;;
		completions|run|ps|logs|kill|show|retry|add|repo|init|tui)
			# Rust-managed commands — pass through all remaining args
			command="$1"
			shift
			break
			;;
		*)
			# If no command yet, treat as command
			if [[ -z "$command" ]]; then
				echo "Unknown command: $1"
				usage
				return 1
			fi
			shift
			;;
		esac
	done

	# Default: launch status (TUI if available, text table otherwise)
	if [[ -z "$command" ]]; then
		cmd_status
		return 0
	fi

	case "$command" in
	start) cmd_start "$start_repo" ;;
	setup) cmd_setup ;;
	doctor) cmd_doctor ;;
	work) cmd_work "$work_repo" ;;
	refresh_docs) cmd_refresh_docs "$refresh_docs_repo" "$refresh_docs_check" ;;
	drain) cmd_drain ;;
	resume) cmd_resume ;;
	status) cmd_status ;;
	merge) cmd_merge "$merge_repo" ;;
	# Delegate Rust-managed commands to sipag-cli
	completions|run|ps|logs|kill|show|retry|add|repo|init|tui)
		if command -v sipag-cli &>/dev/null; then
			exec sipag-cli "$command" "$@"
		else
			echo "Error: sipag-cli not found. Run 'make install' or 'cargo install --path sipag'"
			return 1
		fi
		;;
	esac
}

main "$@"
