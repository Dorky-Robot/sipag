#!/usr/bin/env bash
# sipag — task queue feeder for Claude Code
#
# Reads a markdown checklist, feeds the next unchecked item to claude,
# marks it done, moves on.

set -euo pipefail

SIPAG_VERSION="2.0.0"

# Resolve project root
SIPAG_ROOT="$(cd "$(dirname "$0")/.." && pwd)"

# Source libraries
# shellcheck source=../lib/task.sh
source "${SIPAG_ROOT}/lib/task.sh"
# shellcheck source=../lib/run.sh
source "${SIPAG_ROOT}/lib/run.sh"
# shellcheck source=../lib/repo.sh
source "${SIPAG_ROOT}/lib/repo.sh"
# shellcheck source=../lib/executor.sh
source "${SIPAG_ROOT}/lib/executor.sh"

# --- Defaults ---

SIPAG_DIR="${SIPAG_DIR:-${HOME}/.sipag}"
SIPAG_FILE="${SIPAG_FILE:-./tasks.md}"
CONTINUE=0
DRY_RUN=0
ADD_REPO=""
ADD_PRIORITY="medium"

# --- Help ---

usage() {
	cat <<'EOF'
sipag — task queue feeder for Claude Code

Usage:
  sipag                           Run next unchecked task (same as sipag next)
  sipag init                      Create ~/.sipag/{queue,running,done,failed}
  sipag next [-c] [-n] [-f]      Find first - [ ], run claude, mark - [x]
  sipag list [-f path]            Print all tasks with status
  sipag add "task" [--repo <name>] [--priority <level>]
                                Queue a task (writes YAML frontmatter to queue/)
  sipag show <name>               Print task file and log (searches all dirs)
  sipag retry <name>              Move task from failed/ back to queue/
  sipag start                     Start the executor (auto-inits if needed)
  sipag repo add <name> <url>     Register a repo
  sipag repo list                 List registered repos
  sipag status                    Show queue state across all directories
  sipag version                   Print version
  sipag help                      Show this help

Flags:
  -c, --continue            After completing, loop to the next task
  -n, --dry-run             Show what would run, don't invoke claude
  -f, --file <path>         Task file (default: ./tasks.md or $SIPAG_FILE)
      --repo <name>         Repository name for the queued task
      --priority <level>    Priority level (default: medium)

Environment:
  SIPAG_DIR               Base directory (default: ~/.sipag)
  SIPAG_FILE              Task file path (default: ./tasks.md)
  SIPAG_TIMEOUT           Claude timeout in seconds (default: 600)
  SIPAG_MODEL             Model override
  SIPAG_PROMPT_PREFIX     Prepended to every prompt
  SIPAG_SKIP_PERMISSIONS  Set 0 for interactive mode (default: 1)
  SIPAG_CLAUDE_ARGS       Extra raw args to claude
EOF
}

# --- Commands ---

cmd_init() {
	sipag_init_dirs "${SIPAG_DIR}"
}

cmd_start() {
	sipag_init_dirs "${SIPAG_DIR}" >/dev/null
	echo "sipag executor starting (queue: ${SIPAG_DIR}/queue)"
	executor_run
}

cmd_next() {
	while true; do
		if ! task_parse_next "$SIPAG_FILE"; then
			echo "No pending tasks in ${SIPAG_FILE}"
			return 0
		fi

		echo "==> Task ${TASK_LINE}: ${TASK_TITLE}"

		if [[ $DRY_RUN -eq 1 ]]; then
			if [[ -n "$TASK_BODY" ]]; then
				echo ""
				echo "$TASK_BODY"
			fi
			echo ""
			echo "(dry run — skipping claude)"
			return 0
		fi

		if run_claude "$TASK_TITLE" "$TASK_BODY"; then
			task_mark_done "$SIPAG_FILE" "$TASK_LINE"
			echo "==> Done: ${TASK_TITLE}"
		else
			local rc=$?
			echo "==> Failed (exit ${rc}): ${TASK_TITLE}"
			return $rc
		fi

		if [[ $CONTINUE -eq 0 ]]; then
			return 0
		fi

		echo ""
	done
}

cmd_list() {
	task_list "$SIPAG_FILE"
}

cmd_add() {
	local text="$1"

	if [[ -z "$text" ]]; then
		echo "Usage: sipag add \"task text\" [--repo <name>] [--priority <level>]"
		return 1
	fi

	# Auto-init directory structure if it doesn't exist yet
	if [[ ! -d "${SIPAG_DIR}/queue" ]]; then
		sipag_init_dirs "${SIPAG_DIR}" >/dev/null
	fi

	if [[ -n "$ADD_REPO" ]]; then
		# Frontmatter format: write a named file to queue/
		local filename
		filename=$(task_next_filename "${SIPAG_DIR}/queue" "$text")
		task_write_file "${SIPAG_DIR}/queue/${filename}" "$text" "$ADD_REPO" "$ADD_PRIORITY"
		echo "Added: ${text}"
	else
		# Legacy format: append checklist item to SIPAG_FILE
		task_add "$SIPAG_FILE" "$text"
		echo "Added: ${text}"
	fi
}

cmd_repo() {
	local subcmd="${1:-}"
	local name="${2:-}"
	local url="${3:-}"
	local conf="${SIPAG_DIR}/repos.conf"

	case "$subcmd" in
	add)
		if [[ -z "$name" ]]; then
			echo "Usage: sipag repo add <name> <url>" >&2
			return 1
		fi
		if [[ -z "$url" ]]; then
			echo "Usage: sipag repo add <name> <url>" >&2
			return 1
		fi
		if [[ -f "$conf" ]] && grep -q "^${name}=" "$conf"; then
			echo "Error: repo '${name}' already exists" >&2
			return 1
		fi
		echo "${name}=${url}" >>"$conf"
		echo "Registered: ${name}=${url}"
		;;
	list)
		if [[ ! -f "$conf" ]]; then
			echo "No repos registered. Use: sipag repo add <name> <url>"
			return 0
		fi
		cat "$conf"
		;;
	*)
		echo "Usage: sipag repo add <name> <url>" >&2
		echo "       sipag repo list" >&2
		return 1
		;;
	esac
}

cmd_status() {
	local -a labels=("Queue" "Running" "Done" "Failed")
	local -a subdirs=("queue" "running" "done" "failed")
	local i

	for ((i = 0; i < ${#labels[@]}; i++)); do
		local label="${labels[$i]}"
		local dir="${SIPAG_DIR}/${subdirs[$i]}"
		local -a items=()

		if [[ -d "$dir" ]]; then
			local f
			for f in "${dir}/"*; do
				[[ -e "$f" ]] && items+=("$(basename "$f")")
			done
		fi

		local count="${#items[@]}"
		if [[ $count -gt 0 ]]; then
			echo "${label} (${count}):"
			printf '%s\n' "${items[@]}" | sort | while IFS= read -r item; do
				echo "  ${item}"
			done
		fi
	done
}

cmd_version() {
	echo "sipag ${SIPAG_VERSION}"
}

cmd_show() {
	if [[ $# -eq 0 ]]; then
		echo "Usage: sipag show <name>"
		return 1
	fi
	local name="$1"
	local found_file=""
	local found_status=""
	for dir_status in queue running done failed; do
		local candidate="${SIPAG_DIR}/${dir_status}/${name}.md"
		if [[ -f "$candidate" ]]; then
			found_file="$candidate"
			found_status="$dir_status"
			break
		fi
	done
	if [[ -z "$found_file" ]]; then
		echo "Error: task '${name}' not found"
		return 1
	fi
	echo "=== Task: ${name} ==="
	echo "Status: ${found_status}"
	cat "$found_file"
	local log_file="${SIPAG_DIR}/${found_status}/${name}.log"
	if [[ -f "$log_file" ]]; then
		echo "=== Log ==="
		cat "$log_file"
	fi
}

cmd_retry() {
	if [[ $# -eq 0 ]]; then
		echo "Usage: sipag retry <name>"
		return 1
	fi
	local name="$1"
	local failed_file="${SIPAG_DIR}/failed/${name}.md"
	local log_file="${SIPAG_DIR}/failed/${name}.log"
	if [[ ! -f "$failed_file" ]]; then
		echo "Error: task '${name}' not found in failed/"
		return 1
	fi
	mv "$failed_file" "${SIPAG_DIR}/queue/${name}.md"
	if [[ -f "$log_file" ]]; then
		rm "$log_file"
	fi
	echo "Retrying: ${name} (moved to queue)"
}

# --- Argument parsing ---

main() {
	local command=""
	local add_text=""
	local cmd_name_arg=""
	local repo_subcmd=""
	local repo_name=""
	local repo_url_arg=""

	while [[ $# -gt 0 ]]; do
		case "$1" in
		init)
			command="init"
			shift
			;;
		next)
			command="next"
			shift
			;;
		list)
			command="list"
			shift
			;;
		add)
			command="add"
			shift
			;;
		show)
			command="show"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				cmd_name_arg="$1"
				shift
			fi
			;;
		retry)
			command="retry"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				cmd_name_arg="$1"
				shift
			fi
			;;
		start)
			command="start"
			shift
			;;
		repo)
			command="repo"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				repo_subcmd="$1"
				shift
			fi
			if [[ $# -gt 0 && "$1" != -* ]]; then
				repo_name="$1"
				shift
			fi
			if [[ $# -gt 0 && "$1" != -* ]]; then
				repo_url_arg="$1"
				shift
			fi
			;;
		status)
			command="status"
			shift
			;;
		version | --version)
			cmd_version
			return 0
			;;
		help | --help | -h)
			usage
			return 0
			;;
		-c | --continue)
			CONTINUE=1
			shift
			;;
		-n | --dry-run)
			DRY_RUN=1
			shift
			;;
		-f | --file)
			shift
			SIPAG_FILE="${1:?--file requires a path}"
			shift
			;;
		--repo)
			shift
			ADD_REPO="${1:?--repo requires a name}"
			shift
			;;
		--priority)
			shift
			ADD_PRIORITY="${1:?--priority requires a level}"
			shift
			;;
		-*)
			echo "Unknown flag: $1"
			usage
			return 1
			;;
		*)
			# If no command yet, treat as unknown command
			if [[ -z "$command" ]]; then
				echo "Unknown command: $1"
				usage
				return 1
			fi
			# Capture positional argument for add subcommand
			if [[ "$command" == "add" && -z "$add_text" ]]; then
				add_text="$1"
			fi
			shift
			;;
		esac
	done

	# Default command
	if [[ -z "$command" ]]; then
		command="next"
	fi

	case "$command" in
	init) cmd_init ;;
	next) cmd_next ;;
	list) cmd_list ;;
	add) cmd_add "$add_text" ;;
	show) cmd_show "$cmd_name_arg" ;;
	retry) cmd_retry "$cmd_name_arg" ;;
	start) cmd_start ;;
	repo) cmd_repo "$repo_subcmd" "$repo_name" "$repo_url_arg" ;;
	status) cmd_status ;;
	esac
}

main "$@"
