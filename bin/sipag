#!/usr/bin/env bash
# sipag — task queue feeder for Claude Code
#
# Reads a markdown checklist, feeds the next unchecked item to claude,
# marks it done, moves on.

set -euo pipefail

SIPAG_VERSION="2.0.0"

# Resolve project root
SIPAG_ROOT="$(cd "$(dirname "$0")/.." && pwd)"

# Source libraries
# shellcheck source=../lib/task.sh
source "${SIPAG_ROOT}/lib/task.sh"
# shellcheck source=../lib/run.sh
source "${SIPAG_ROOT}/lib/run.sh"

# --- Defaults ---

SIPAG_DIR="${SIPAG_DIR:-${HOME}/.sipag}"
SIPAG_FILE="${SIPAG_FILE:-./tasks.md}"
CONTINUE=0
DRY_RUN=0
ADD_REPO=""
ADD_PRIORITY="medium"

# --- Help ---

usage() {
	cat <<'EOF'
sipag — task queue feeder for Claude Code

Usage:
  sipag                        Run next unchecked task (same as sipag next)
  sipag init                   Create ~/.sipag/{queue,running,done,failed}
  sipag next [-c] [-n] [-f]   Find first - [ ], run claude, mark - [x]
  sipag list [-f path]         Print all tasks with status
  sipag add "task" [--repo <name>] [--priority <level>]
                               Queue a task (writes YAML frontmatter to queue/)
  sipag start                  Start the executor (auto-inits if needed)
  sipag version                Print version
  sipag help                   Show this help

Flags:
  -c, --continue            After completing, loop to the next task
  -n, --dry-run             Show what would run, don't invoke claude
  -f, --file <path>         Task file (default: ./tasks.md or $SIPAG_FILE)
      --repo <name>         Repository name for the queued task
      --priority <level>    Priority level (default: medium)

Environment:
  SIPAG_DIR               Base directory (default: ~/.sipag)
  SIPAG_FILE              Task file path (default: ./tasks.md)
  SIPAG_TIMEOUT           Claude timeout in seconds (default: 600)
  SIPAG_MODEL             Model override
  SIPAG_PROMPT_PREFIX     Prepended to every prompt
  SIPAG_SKIP_PERMISSIONS  Set 0 for interactive mode (default: 1)
  SIPAG_CLAUDE_ARGS       Extra raw args to claude
EOF
}

# --- Commands ---

cmd_init() {
	sipag_init_dirs "${SIPAG_DIR}"
}

cmd_start() {
	sipag_init_dirs "${SIPAG_DIR}" >/dev/null
	echo "sipag executor starting (queue: ${SIPAG_DIR}/queue)"
	echo "No tasks in queue — use 'sipag add' to queue a task"
}

cmd_next() {
	while true; do
		if ! task_parse_next "$SIPAG_FILE"; then
			echo "No pending tasks in ${SIPAG_FILE}"
			return 0
		fi

		echo "==> Task ${TASK_LINE}: ${TASK_TITLE}"

		if [[ $DRY_RUN -eq 1 ]]; then
			if [[ -n "$TASK_BODY" ]]; then
				echo ""
				echo "$TASK_BODY"
			fi
			echo ""
			echo "(dry run — skipping claude)"
			return 0
		fi

		if run_claude "$TASK_TITLE" "$TASK_BODY"; then
			task_mark_done "$SIPAG_FILE" "$TASK_LINE"
			echo "==> Done: ${TASK_TITLE}"
		else
			local rc=$?
			echo "==> Failed (exit ${rc}): ${TASK_TITLE}"
			return $rc
		fi

		if [[ $CONTINUE -eq 0 ]]; then
			return 0
		fi

		echo ""
	done
}

cmd_list() {
	task_list "$SIPAG_FILE"
}

cmd_add() {
	local text="$1"

	if [[ -z "$text" ]]; then
		echo "Usage: sipag add \"task text\" [--repo <name>] [--priority <level>]"
		return 1
	fi

	# Auto-init directory structure if it doesn't exist yet
	if [[ ! -d "${SIPAG_DIR}/queue" ]]; then
		sipag_init_dirs "${SIPAG_DIR}" >/dev/null
	fi

	if [[ -n "$ADD_REPO" ]]; then
		# Frontmatter format: write a named file to queue/
		local filename
		filename=$(task_next_filename "${SIPAG_DIR}/queue" "$text")
		task_write_file "${SIPAG_DIR}/queue/${filename}" "$text" "$ADD_REPO" "$ADD_PRIORITY"
		echo "Added: ${text}"
	else
		# Legacy format: append checklist item to SIPAG_FILE
		task_add "$SIPAG_FILE" "$text"
		echo "Added: ${text}"
	fi
}

cmd_version() {
	echo "sipag ${SIPAG_VERSION}"
}

# --- Argument parsing ---

main() {
	local command=""
	local add_text=""

	while [[ $# -gt 0 ]]; do
		case "$1" in
		init)
			command="init"
			shift
			;;
		next)
			command="next"
			shift
			;;
		list)
			command="list"
			shift
			;;
		add)
			command="add"
			shift
			;;
		start)
			command="start"
			shift
			;;
		version | --version)
			cmd_version
			return 0
			;;
		help | --help | -h)
			usage
			return 0
			;;
		-c | --continue)
			CONTINUE=1
			shift
			;;
		-n | --dry-run)
			DRY_RUN=1
			shift
			;;
		-f | --file)
			shift
			SIPAG_FILE="${1:?--file requires a path}"
			shift
			;;
		--repo)
			shift
			ADD_REPO="${1:?--repo requires a name}"
			shift
			;;
		--priority)
			shift
			ADD_PRIORITY="${1:?--priority requires a level}"
			shift
			;;
		-*)
			echo "Unknown flag: $1"
			usage
			return 1
			;;
		*)
			# If no command yet, treat as unknown command
			if [[ -z "$command" ]]; then
				echo "Unknown command: $1"
				usage
				return 1
			fi
			# Capture positional argument for add subcommand
			if [[ "$command" == "add" && -z "$add_text" ]]; then
				add_text="$1"
			fi
			shift
			;;
		esac
	done

	# Default command
	if [[ -z "$command" ]]; then
		command="next"
	fi

	case "$command" in
	init) cmd_init ;;
	next) cmd_next ;;
	list) cmd_list ;;
	add) cmd_add "$add_text" ;;
	start) cmd_start ;;
	esac
}

main "$@"
