#!/usr/bin/env bash
# sipag — sandbox launcher for Claude Code
#
# Claude Code is the orchestrator. sipag spins up isolated Docker sandboxes
# and makes progress visible.

set -euo pipefail

SIPAG_VERSION="2.0.0"

# Resolve project root
SIPAG_ROOT="$(cd "$(dirname "$0")/.." && pwd)"

# Source libraries
# shellcheck source=../lib/task.sh
source "${SIPAG_ROOT}/lib/task.sh"
# shellcheck source=../lib/run.sh
source "${SIPAG_ROOT}/lib/run.sh"
# shellcheck source=../lib/repo.sh
source "${SIPAG_ROOT}/lib/repo.sh"
# shellcheck source=../lib/executor.sh
source "${SIPAG_ROOT}/lib/executor.sh"

# --- Defaults ---

SIPAG_DIR="${SIPAG_DIR:-${HOME}/.sipag}"
SIPAG_FILE="${SIPAG_FILE:-./tasks.md}"
CONTINUE=0
DRY_RUN=0
ADD_REPO=""
ADD_PRIORITY="medium"

# --- Help ---

usage() {
	cat <<'EOF'
sipag — sandbox launcher for Claude Code

Usage:
  sipag run --repo <url> [--issue <n>] [-b] "<task>"
                                Launch a Docker sandbox for a task
  sipag ps                      List running and recent tasks
  sipag logs <id>               Print log for a task
  sipag kill <id>               Kill a running task container
  sipag start                   Process queue/ serially (uses sipag run internally)
  sipag init                    Create ~/.sipag/{queue,running,done,failed}
  sipag add "task" [--repo <name>] [--priority <level>]
                                Queue a task (writes YAML frontmatter to queue/)
  sipag list [-f path]          Print all tasks with status
  sipag next [-c] [-n] [-f]     Find first - [ ], run claude, mark - [x]
  sipag show <name>             Print task file and log (searches all dirs)
  sipag retry <name>            Move task from failed/ back to queue/
  sipag repo add <name> <url>   Register a repo
  sipag repo list               List registered repos
  sipag stats                   Show aggregate task stats (counts and durations)
  sipag status                  Show queue state across all directories
  sipag version                 Print version
  sipag help                    Show this help

Run flags:
  --repo <url>              Repository URL to clone (required)
  --issue <n>               GitHub issue number to associate
  -b, --background          Run in background (default: foreground)

Queue flags:
  -c, --continue            After completing, loop to the next task
  -n, --dry-run             Show what would run, don't invoke claude
  -f, --file <path>         Task file (default: ./tasks.md or $SIPAG_FILE)
      --repo <name>         Repository name for the queued task
      --priority <level>    Priority level (default: medium)

Environment:
  SIPAG_DIR               Base directory (default: ~/.sipag)
  SIPAG_FILE              Task file path (default: ./tasks.md)
  SIPAG_IMAGE             Docker base image (default: sipag-worker:latest)
  SIPAG_TIMEOUT           Container timeout in seconds (default: 1800)
  SIPAG_MODEL             Model override
  SIPAG_PROMPT_PREFIX     Prepended to every prompt
  SIPAG_SKIP_PERMISSIONS  Set 0 for interactive mode (default: 1)
  SIPAG_CLAUDE_ARGS       Extra raw args to claude
EOF
}

# --- Commands ---

cmd_init() {
	sipag_init_dirs "${SIPAG_DIR}"
}

cmd_start() {
	sipag_init_dirs "${SIPAG_DIR}" >/dev/null
	echo "sipag executor starting (queue: ${SIPAG_DIR}/queue)"
	executor_run
}

cmd_next() {
	while true; do
		if ! task_parse_next "$SIPAG_FILE"; then
			echo "No pending tasks in ${SIPAG_FILE}"
			return 0
		fi

		echo "==> Task ${TASK_LINE}: ${TASK_TITLE}"

		if [[ $DRY_RUN -eq 1 ]]; then
			if [[ -n "$TASK_BODY" ]]; then
				echo ""
				echo "$TASK_BODY"
			fi
			echo ""
			echo "(dry run — skipping claude)"
			return 0
		fi

		if run_claude "$TASK_TITLE" "$TASK_BODY"; then
			task_mark_done "$SIPAG_FILE" "$TASK_LINE"
			echo "==> Done: ${TASK_TITLE}"
		else
			local rc=$?
			echo "==> Failed (exit ${rc}): ${TASK_TITLE}"
			return $rc
		fi

		if [[ $CONTINUE -eq 0 ]]; then
			return 0
		fi

		echo ""
	done
}

cmd_list() {
	task_list "$SIPAG_FILE"
}

cmd_add() {
	local text="$1"

	if [[ -z "$text" ]]; then
		echo "Usage: sipag add \"task text\" [--repo <name>] [--priority <level>]"
		return 1
	fi

	# Auto-init directory structure if it doesn't exist yet
	if [[ ! -d "${SIPAG_DIR}/queue" ]]; then
		sipag_init_dirs "${SIPAG_DIR}" >/dev/null
	fi

	if [[ -n "$ADD_REPO" ]]; then
		# Frontmatter format: write a named file to queue/
		local filename
		filename=$(task_next_filename "${SIPAG_DIR}/queue" "$text")
		task_write_file "${SIPAG_DIR}/queue/${filename}" "$text" "$ADD_REPO" "$ADD_PRIORITY"
		echo "Added: ${text}"
	else
		# Legacy format: append checklist item to SIPAG_FILE
		task_add "$SIPAG_FILE" "$text"
		echo "Added: ${text}"
	fi
}

cmd_repo() {
	local subcmd="${1:-}"
	local name="${2:-}"
	local url="${3:-}"
	local conf="${SIPAG_DIR}/repos.conf"

	case "$subcmd" in
	add)
		if [[ -z "$name" ]]; then
			echo "Usage: sipag repo add <name> <url>" >&2
			return 1
		fi
		if [[ -z "$url" ]]; then
			echo "Usage: sipag repo add <name> <url>" >&2
			return 1
		fi
		if [[ -f "$conf" ]] && grep -q "^${name}=" "$conf"; then
			echo "Error: repo '${name}' already exists" >&2
			return 1
		fi
		echo "${name}=${url}" >>"$conf"
		echo "Registered: ${name}=${url}"
		;;
	list)
		if [[ ! -f "$conf" ]]; then
			echo "No repos registered. Use: sipag repo add <name> <url>"
			return 0
		fi
		cat "$conf"
		;;
	*)
		echo "Usage: sipag repo add <name> <url>" >&2
		echo "       sipag repo list" >&2
		return 1
		;;
	esac
}

cmd_status() {
	local -a labels=("Queue" "Running" "Done" "Failed")
	local -a subdirs=("queue" "running" "done" "failed")
	local i

	for ((i = 0; i < ${#labels[@]}; i++)); do
		local label="${labels[$i]}"
		local dir="${SIPAG_DIR}/${subdirs[$i]}"
		local -a items=()

		if [[ -d "$dir" ]]; then
			local f
			for f in "${dir}/"*; do
				[[ -e "$f" ]] && items+=("$(basename "$f")")
			done
		fi

		local count="${#items[@]}"
		if [[ $count -gt 0 ]]; then
			echo "${label} (${count}):"
			printf '%s\n' "${items[@]}" | sort | while IFS= read -r item; do
				echo "  ${item}"
			done
		fi
	done
}

cmd_version() {
	echo "sipag ${SIPAG_VERSION}"
}

cmd_show() {
	if [[ $# -eq 0 ]]; then
		echo "Usage: sipag show <name>"
		return 1
	fi
	local name="$1"
	local found_file=""
	local found_status=""
	for dir_status in queue running done failed; do
		local candidate="${SIPAG_DIR}/${dir_status}/${name}.md"
		if [[ -f "$candidate" ]]; then
			found_file="$candidate"
			found_status="$dir_status"
			break
		fi
	done
	if [[ -z "$found_file" ]]; then
		echo "Error: task '${name}' not found"
		return 1
	fi
	echo "=== Task: ${name} ==="
	echo "Status: ${found_status}"
	cat "$found_file"
	local log_file="${SIPAG_DIR}/${found_status}/${name}.log"
	if [[ -f "$log_file" ]]; then
		echo "=== Log ==="
		cat "$log_file"
	fi
}

cmd_retry() {
	if [[ $# -eq 0 ]]; then
		echo "Usage: sipag retry <name>"
		return 1
	fi
	local name="$1"
	local failed_file="${SIPAG_DIR}/failed/${name}.md"
	local log_file="${SIPAG_DIR}/failed/${name}.log"
	if [[ ! -f "$failed_file" ]]; then
		echo "Error: task '${name}' not found in failed/"
		return 1
	fi
	mv "$failed_file" "${SIPAG_DIR}/queue/${name}.md"
	if [[ -f "$log_file" ]]; then
		rm "$log_file"
	fi
	echo "Retrying: ${name} (moved to queue)"
}

# sipag run — launch a Docker sandbox for a task
cmd_run() {
	local repo_url=""
	local issue=""
	local background=0
	local description=""

	while [[ $# -gt 0 ]]; do
		case "$1" in
		--repo)
			shift
			repo_url="${1:?--repo requires a URL}"
			shift
			;;
		--issue)
			shift
			issue="${1:?--issue requires a number}"
			shift
			;;
		-b | --background)
			background=1
			shift
			;;
		-*)
			echo "Unknown flag: $1" >&2
			echo "Usage: sipag run --repo <url> [--issue <n>] [-b] \"<task>\"" >&2
			return 1
			;;
		*)
			description="$1"
			shift
			;;
		esac
	done

	if [[ -z "$repo_url" ]]; then
		echo "Usage: sipag run --repo <url> [--issue <n>] [-b] \"<task>\"" >&2
		echo "  --repo is required" >&2
		return 1
	fi

	if [[ -z "$description" ]]; then
		echo "Usage: sipag run --repo <url> [--issue <n>] [-b] \"<task>\"" >&2
		echo "  task description is required" >&2
		return 1
	fi

	# Auto-init if needed
	if [[ ! -d "${SIPAG_DIR}/running" ]]; then
		sipag_init_dirs "${SIPAG_DIR}" >/dev/null
	fi

	# Generate unique task ID from timestamp + slugified description
	local slug
	slug=$(task_slugify "$description")
	local task_id
	task_id="$(date +%Y%m%d%H%M%S)-${slug:0:30}"
	# Strip trailing hyphens from the slug portion
	task_id="${task_id%-}"

	echo "Task ID: ${task_id}"

	executor_run_impl "${task_id}" "${repo_url}" "${description}" "${issue}" "${background}"
}

# sipag ps — list running and recent tasks
cmd_ps() {
	local now
	now=$(date +%s)

	printf '%-44s  %-8s  %-10s  %s\n' "ID" "STATUS" "DURATION" "REPO"

	local found=0
	for dir_status in running done failed; do
		local dir="${SIPAG_DIR}/${dir_status}"
		[[ -d "$dir" ]] || continue

		local f
		for f in "${dir}"/*.md; do
			[[ -f "$f" ]] || continue

			local task_id
			task_id="$(basename "$f" .md)"

			# Parse metadata from tracking file
			local repo started completed stored_dur
			repo=$(grep -m1 "^repo:" "$f" 2>/dev/null | cut -d' ' -f2- || true)
			started=$(grep -m1 "^started:" "$f" 2>/dev/null | cut -d' ' -f2- || true)
			completed=$(grep -m1 "^completed:" "$f" 2>/dev/null | cut -d' ' -f2- || true)
			# Backwards compat: also check ended: (pre-stats tracking files)
			if [[ -z "$completed" ]]; then
				completed=$(grep -m1 "^ended:" "$f" 2>/dev/null | cut -d' ' -f2- || true)
			fi
			stored_dur=$(grep -m1 "^duration:" "$f" 2>/dev/null | cut -d' ' -f2- || true)

			# Compute duration
			local duration="-"
			if [[ -n "$stored_dur" && "$dir_status" != "running" ]]; then
				duration="$stored_dur"
			elif [[ -n "$started" ]]; then
				local started_epoch end_epoch diff
				started_epoch=$(_ts_to_epoch "$started")
				if [[ -n "$completed" ]]; then
					end_epoch=$(_ts_to_epoch "$completed")
				else
					end_epoch="$now"
				fi
				diff=$((end_epoch - started_epoch))
				[[ $diff -lt 0 ]] && diff=0
				duration=$(_secs_to_dur "$diff")
			fi

			printf '%-44s  %-8s  %-10s  %s\n' \
				"${task_id:0:44}" "${dir_status}" "${duration}" "${repo:-unknown}"
			found=1
		done
	done

	if [[ "$found" -eq 0 ]]; then
		echo "No tasks found."
	fi
}

# sipag stats — show aggregate task stats
cmd_stats() {
	local done_dir="${SIPAG_DIR}/done"
	local failed_dir="${SIPAG_DIR}/failed"
	local queue_dir="${SIPAG_DIR}/queue"
	local running_dir="${SIPAG_DIR}/running"

	local total_done=0
	local total_failed=0
	local total_pending=0
	local f

	if [[ -d "$done_dir" ]]; then
		for f in "${done_dir}"/*.md; do [[ -f "$f" ]] && total_done=$((total_done + 1)); done
	fi
	if [[ -d "$failed_dir" ]]; then
		for f in "${failed_dir}"/*.md; do [[ -f "$f" ]] && total_failed=$((total_failed + 1)); done
	fi
	if [[ -d "$queue_dir" ]]; then
		for f in "${queue_dir}"/*.md; do [[ -f "$f" ]] && total_pending=$((total_pending + 1)); done
	fi
	if [[ -d "$running_dir" ]]; then
		for f in "${running_dir}"/*.md; do [[ -f "$f" ]] && total_pending=$((total_pending + 1)); done
	fi

	local total=$((total_done + total_failed + total_pending))

	# Aggregate duration stats from done/ and failed/ task files
	local total_secs=0
	local dur_count=0
	local max_secs=0
	local longest_name=""
	local dir secs stored_dur started completed

	for dir in "$done_dir" "$failed_dir"; do
		[[ -d "$dir" ]] || continue
		for f in "${dir}"/*.md; do
			[[ -f "$f" ]] || continue
			secs=0
			stored_dur=$(grep -m1 "^duration:" "$f" 2>/dev/null | cut -d' ' -f2- || true)
			if [[ -n "$stored_dur" ]]; then
				secs=$(_dur_to_secs "$stored_dur")
			else
				started=$(grep -m1 "^started:" "$f" 2>/dev/null | cut -d' ' -f2- || true)
				completed=$(grep -m1 "^completed:" "$f" 2>/dev/null | cut -d' ' -f2- || true)
				if [[ -z "$completed" ]]; then
					completed=$(grep -m1 "^ended:" "$f" 2>/dev/null | cut -d' ' -f2- || true)
				fi
				if [[ -z "$started" || -z "$completed" ]]; then
					continue
				fi
				secs=$(_ts_diff_secs "$started" "$completed")
			fi
			total_secs=$((total_secs + secs))
			dur_count=$((dur_count + 1))
			if [[ $secs -gt $max_secs ]]; then
				max_secs=$secs
				longest_name="$(basename "$f" .md)"
			fi
		done
	done

	local sep="─────────────────────────"
	echo "$sep"
	printf 'Total tasks:     %s\n' "$total"
	if [[ $total -gt 0 ]]; then
		printf 'Completed:       %s (%s%%)\n' "$total_done" "$((total_done * 100 / total))"
		printf 'Failed:          %s (%s%%)\n' "$total_failed" "$((total_failed * 100 / total))"
	else
		printf 'Completed:       %s\n' "$total_done"
		printf 'Failed:          %s\n' "$total_failed"
	fi
	printf 'Pending:         %s\n' "$total_pending"
	echo ""
	if [[ $dur_count -gt 0 ]]; then
		printf 'Avg duration:    %s\n' "$(_secs_to_dur "$((total_secs / dur_count))")"
		printf 'Total time:      %s\n' "$(_secs_to_dur "$total_secs")"
		printf 'Longest:         %s (%s)\n' "$(_secs_to_dur "$max_secs")" "$longest_name"
	else
		echo "No duration data available."
	fi
	echo "$sep"
}

# sipag logs <id> — print log for a task
cmd_logs() {
	local task_id="${1:-}"
	if [[ -z "$task_id" ]]; then
		echo "Usage: sipag logs <id>" >&2
		return 1
	fi

	for dir_status in running done failed; do
		local log_file="${SIPAG_DIR}/${dir_status}/${task_id}.log"
		if [[ -f "$log_file" ]]; then
			cat "$log_file"
			return 0
		fi
	done

	echo "Error: no log found for task '${task_id}'" >&2
	return 1
}

# sipag kill <id> — kill a running container and move task to failed/
cmd_kill() {
	local task_id="${1:-}"
	if [[ -z "$task_id" ]]; then
		echo "Usage: sipag kill <id>" >&2
		return 1
	fi

	local tracking_file="${SIPAG_DIR}/running/${task_id}.md"
	if [[ ! -f "$tracking_file" ]]; then
		echo "Error: task '${task_id}' not found in running/" >&2
		return 1
	fi

	# Container name is deterministic: sipag-<task_id>
	local container_name="sipag-${task_id}"

	# Kill the Docker container (ignore errors if already stopped)
	docker kill "${container_name}" 2>/dev/null || true

	# Move task and log to failed/
	local log_file="${SIPAG_DIR}/running/${task_id}.log"
	mv "${tracking_file}" "${SIPAG_DIR}/failed/${task_id}.md"
	[[ -f "$log_file" ]] && mv "$log_file" "${SIPAG_DIR}/failed/${task_id}.log"

	echo "Killed: ${task_id}"
}

# --- Argument parsing ---

main() {
	local command=""
	local add_text=""
	local cmd_name_arg=""
	local repo_subcmd=""
	local repo_name=""
	local repo_url_arg=""
	local -a run_args=()

	while [[ $# -gt 0 ]]; do
		case "$1" in
		init)
			command="init"
			shift
			;;
		next)
			command="next"
			shift
			;;
		list)
			command="list"
			shift
			;;
		add)
			command="add"
			shift
			;;
		show)
			command="show"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				cmd_name_arg="$1"
				shift
			fi
			;;
		retry)
			command="retry"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				cmd_name_arg="$1"
				shift
			fi
			;;
		start)
			command="start"
			shift
			;;
		run)
			command="run"
			shift
			run_args=("$@")
			break
			;;
		ps)
			command="ps"
			shift
			;;
		logs)
			command="logs"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				cmd_name_arg="$1"
				shift
			fi
			;;
		kill)
			command="kill"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				cmd_name_arg="$1"
				shift
			fi
			;;
		repo)
			command="repo"
			shift
			if [[ $# -gt 0 && "$1" != -* ]]; then
				repo_subcmd="$1"
				shift
			fi
			if [[ $# -gt 0 && "$1" != -* ]]; then
				repo_name="$1"
				shift
			fi
			if [[ $# -gt 0 && "$1" != -* ]]; then
				repo_url_arg="$1"
				shift
			fi
			;;
		stats)
			command="stats"
			shift
			;;
		status)
			command="status"
			shift
			;;
		version | --version)
			cmd_version
			return 0
			;;
		help | --help | -h)
			usage
			return 0
			;;
		-c | --continue)
			CONTINUE=1
			shift
			;;
		-n | --dry-run)
			DRY_RUN=1
			shift
			;;
		-f | --file)
			shift
			SIPAG_FILE="${1:?--file requires a path}"
			shift
			;;
		--repo)
			shift
			ADD_REPO="${1:?--repo requires a name}"
			shift
			;;
		--priority)
			shift
			ADD_PRIORITY="${1:?--priority requires a level}"
			shift
			;;
		-*)
			echo "Unknown flag: $1"
			usage
			return 1
			;;
		*)
			# If no command yet, treat as unknown command
			if [[ -z "$command" ]]; then
				echo "Unknown command: $1"
				usage
				return 1
			fi
			# Capture positional argument for add subcommand
			if [[ "$command" == "add" && -z "$add_text" ]]; then
				add_text="$1"
			fi
			shift
			;;
		esac
	done

	# Default command
	if [[ -z "$command" ]]; then
		command="next"
	fi

	case "$command" in
	init) cmd_init ;;
	next) cmd_next ;;
	list) cmd_list ;;
	add) cmd_add "$add_text" ;;
	show) cmd_show "$cmd_name_arg" ;;
	retry) cmd_retry "$cmd_name_arg" ;;
	start) cmd_start ;;
	run) cmd_run "${run_args[@]+"${run_args[@]}"}" ;;
	ps) cmd_ps ;;
	logs) cmd_logs "$cmd_name_arg" ;;
	kill) cmd_kill "$cmd_name_arg" ;;
	repo) cmd_repo "$repo_subcmd" "$repo_name" "$repo_url_arg" ;;
	stats) cmd_stats ;;
	status) cmd_status ;;
	esac
}

main "$@"
