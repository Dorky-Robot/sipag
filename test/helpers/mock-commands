#!/usr/bin/env bash
# sipag â€” BATS mock-command helpers
#
# create_mock <name> <exit_code> <stdout>
#   Installs a fake executable in TEST_TMPDIR/bin/ that:
#     - increments a per-invocation counter (TEST_TMPDIR/calls/<name>.count)
#     - appends all arguments (space-joined) to a log file
#       (TEST_TMPDIR/calls/<name>.args)
#     - prints <stdout> to stdout
#     - exits with <exit_code>
#
# mock_call_count <name>
#   Prints the number of times the mock was invoked.
#
# get_mock_calls <name>
#   Prints all recorded argument text for the mock (may span multiple lines
#   if any argument contains newlines, e.g. a system prompt).

create_mock() {
    local name="$1"
    local exit_code="${2:-0}"
    local output="${3:-}"
    local mock_dir="${TEST_TMPDIR}/bin"
    local calls_dir="${TEST_TMPDIR}/calls"
    local count_log="${calls_dir}/${name}.count"
    local args_log="${calls_dir}/${name}.args"

    mkdir -p "${mock_dir}" "${calls_dir}"

    # Use a dedicated count file (one line per call) so that multiline
    # arguments in the args log do not skew the call count.
    cat > "${mock_dir}/${name}" <<MOCK_SCRIPT
#!/usr/bin/env bash
echo "1" >> "${count_log}"
printf '%s\n' "\$*" >> "${args_log}"
printf '%s' "${output}"
exit ${exit_code}
MOCK_SCRIPT

    chmod +x "${mock_dir}/${name}"
}

mock_call_count() {
    local name="$1"
    local count_log="${TEST_TMPDIR}/calls/${name}.count"
    if [[ ! -f "${count_log}" ]]; then
        echo 0
        return
    fi
    wc -l < "${count_log}" | tr -d ' '
}

get_mock_calls() {
    local name="$1"
    local args_log="${TEST_TMPDIR}/calls/${name}.args"
    if [[ -f "${args_log}" ]]; then
        cat "${args_log}"
    fi
}
