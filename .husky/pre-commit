#!/usr/bin/env bash

# Get the staged diff (only what's being committed)
DIFF=$(git diff --cached --diff-filter=ACMR)

if [[ -z "$DIFF" ]]; then
  exit 0
fi

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)

# --- Security scan: block secrets before they reach any reviewer ---

SCRIPT_DIR="$(cd "$(dirname "$0")/../scripts" && pwd)"
# shellcheck source=../scripts/secrets-scan.sh
source "$SCRIPT_DIR/secrets-scan.sh"
scan_secrets "pre-commit" || exit 1

# --- Deterministic quality checks ---

echo "pre-commit: checking for typos..."
if ! typos --format brief; then
  echo ""
  echo "pre-commit: BLOCKED — typos found. Fix them or add to _typos.toml to ignore."
  exit 1
fi

echo "pre-commit: running shellcheck..."
# Find all staged .sh files
SH_FILES=$(echo "$STAGED_FILES" | grep '\.sh$' || true)
if [[ -n "$SH_FILES" ]]; then
  SHELLCHECK_FAILED=0
  while IFS= read -r f; do
    [[ -z "$f" ]] && continue
    if [[ -f "$f" ]]; then
      if ! shellcheck -x --severity=warning "$f"; then
        SHELLCHECK_FAILED=1
      fi
    fi
  done <<<"$SH_FILES"
  if [[ "$SHELLCHECK_FAILED" -ne 0 ]]; then
    echo ""
    echo "pre-commit: BLOCKED — shellcheck found issues. Fix them and try again."
    exit 1
  fi
fi

echo "pre-commit: checking formatting..."
if command -v shfmt &>/dev/null; then
  SH_ALL=()
  while IFS= read -r f; do
    [[ -n "$f" ]] && SH_ALL+=("$f")
  done < <(find bin/ lib/ scripts/ -name '*.sh' -o -name 'sipag' 2>/dev/null | head -50)
  if [[ "${#SH_ALL[@]}" -gt 0 ]]; then
    if ! shfmt -d -i 2 -ci "${SH_ALL[@]}" 2>/dev/null; then
      echo ""
      echo "pre-commit: BLOCKED — formatting issues found. Run 'shfmt -w -i 2 -ci' to fix."
      exit 1
    fi
  fi
fi

# --- Smart test mapping: run only tests affected by staged files ---

if command -v bats &>/dev/null; then
  map_to_test() {
    case "$1" in
      lib/hooks/safety-gate.sh)  echo "test/unit/safety-gate.bats" ;;
      lib/core/config.sh)        echo "test/unit/config.bats" ;;
      lib/core/log.sh)           echo "test/unit/log.bats" ;;
      lib/core/pool.sh)          echo "test/unit/pool.bats" ;;
      lib/core/worker.sh)        echo "test/unit/worker-state.bats test/integration/worker.bats" ;;
      lib/sources/github.sh)     echo "test/integration/github-source.bats" ;;
      bin/sipag)                 echo "test/integration/cli.bats" ;;
      test/unit/*.bats|test/integration/*.bats) echo "$1" ;;
      test/helpers/*.bash)       echo "test/unit/ test/integration/" ;;
    esac
  }

  TO_RUN=()
  while IFS= read -r f; do
    [[ -z "$f" ]] && continue
    mapped=$(map_to_test "$f")
    if [[ -n "$mapped" ]]; then
      for item in $mapped; do
        TO_RUN+=("$item")
      done
    fi
  done <<< "$STAGED_FILES"

  # Deduplicate and collapse: if a directory is listed, drop individual files from it
  if [[ "${#TO_RUN[@]}" -gt 0 ]]; then
    # Deduplicate
    readarray -t TO_RUN < <(printf '%s\n' "${TO_RUN[@]}" | sort -u)

    HAS_UNIT_DIR=false
    HAS_INTEG_DIR=false
    for item in "${TO_RUN[@]}"; do
      [[ "$item" == "test/unit/" ]] && HAS_UNIT_DIR=true
      [[ "$item" == "test/integration/" ]] && HAS_INTEG_DIR=true
    done

    VALID=()
    for item in "${TO_RUN[@]}"; do
      [[ -e "$item" ]] || continue
      # Skip individual files when their directory is already included
      if $HAS_UNIT_DIR && [[ "$item" == test/unit/*.bats ]]; then
        continue
      fi
      if $HAS_INTEG_DIR && [[ "$item" == test/integration/*.bats ]]; then
        continue
      fi
      VALID+=("$item")
    done
    if [[ "${#VALID[@]}" -gt 0 ]]; then
      echo "pre-commit: running mapped tests: ${VALID[*]}"
      if ! bats --jobs 1 "${VALID[@]}"; then
        echo ""
        echo "pre-commit: BLOCKED — tests failed."
        exit 1
      fi
    fi
  fi
fi

echo "pre-commit: all checks passed"
exit 0
